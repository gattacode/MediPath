/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package com.medipath.main;

import java.util.Random;
import com.formdev.flatlaf.FlatIntelliJLaf;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Desktop;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.RenderingHints;
import java.awt.Toolkit;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.io.File;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.ImageIcon;
import javax.swing.JComboBox;
import javax.swing.JFileChooser;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTable;
import javax.swing.filechooser.FileNameExtensionFilter;
import javax.swing.table.DefaultTableModel;
import com.medipath.model.CentreDeSante;
import com.medipath.model.Graphe;
import com.medipath.model.Pair;
import com.medipath.model.Route;
import javax.swing.JSlider;

/**
 * Main de l'application Medipath
 *
 * @author gatta
 */
public class MainApplication extends javax.swing.JFrame {

    private String adjacenceFilePath; // Chemin du fichier de liste d'adjacence

    private String voisinFilePath; // Chemin du fichier de liste des voisins

    private Graphe graphe; // Graphe utilisé dans l'application

    private boolean fichiersChoisis = false; // Indique si les fichiers ont été choisis

    private CentreDeSante draggedCentre = null; // Centre de santé en cours de déplacement

    private Map<CentreDeSante, Rectangle> points = new HashMap<>(); // Points représentant les centres de santé dans le graphique

    /**
     * Crée une nouvelle instance de MainApplication.
     */
    public MainApplication() {
        initComponents();
        icon();
    }

    /**
     * Définit l'icône de l'application.
     */
    public final void icon() {
        this.setIconImage(Toolkit.getDefaultToolkit().getImage(getClass().getResource("/iconmedipath.png")));
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        principalMenuPanel = new javax.swing.JPanel();
        logoLabel = new javax.swing.JLabel();
        menuTabbedPane = new javax.swing.JTabbedPane();
        grapheMenuPanel = new javax.swing.JPanel();
        chargementMenuPanel = new javax.swing.JPanel();
        adjacenceListButton = new javax.swing.JButton();
        voisinListButton = new javax.swing.JButton();
        adjacenceListStatusLabel = new javax.swing.JLabel();
        voisinListStatusLabel = new javax.swing.JLabel();
        grapheCreationButton = new javax.swing.JButton();
        jSeparator1 = new javax.swing.JSeparator();
        editFilePanel = new javax.swing.JPanel();
        editAdjacenceFileButton = new javax.swing.JButton();
        editVoisinFileButton = new javax.swing.JButton();
        jSeparator2 = new javax.swing.JSeparator();
        editPanel = new javax.swing.JPanel();
        addCentreButton = new javax.swing.JButton();
        addRouteButton = new javax.swing.JButton();
        editCentreButton = new javax.swing.JButton();
        editRouteButton = new javax.swing.JButton();
        deleteCentreButton = new javax.swing.JButton();
        deleteRouteButton = new javax.swing.JButton();
        jSeparator3 = new javax.swing.JSeparator();
        listPanel = new javax.swing.JPanel();
        centreListButton = new javax.swing.JButton();
        routeListButton = new javax.swing.JButton();
        infoGrapheButton = new javax.swing.JButton();
        routesParFiabiliteButton = new javax.swing.JButton();
        centreParTypeButton = new javax.swing.JButton();
        cheminMenuPanel = new javax.swing.JPanel();
        jPanel3 = new javax.swing.JPanel();
        cheminPlusCourtDistanceButton = new javax.swing.JButton();
        cheminPlusCourtDureeButton = new javax.swing.JButton();
        cheminPlusFiableButton1 = new javax.swing.JButton();
        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        voisinagePanel = new javax.swing.JPanel();
        jPanel2 = new javax.swing.JPanel();
        listVoisinButton = new javax.swing.JButton();
        listVoisinTypeButton = new javax.swing.JButton();
        listVoisin2CentreTypeButton = new javax.swing.JButton();
        voisin2DistancesOuNonButton = new javax.swing.JButton();
        compare2CentresButton = new javax.swing.JButton();
        legendePanel = new javax.swing.JPanel();
        jLabel3 = new javax.swing.JLabel();
        typePanel = new javax.swing.JPanel();
        jLabel4 = new javax.swing.JLabel();
        jLabel5 = new javax.swing.JLabel();
        jLabel6 = new javax.swing.JLabel();
        graphPanel = new javax.swing.JPanel();
        jMenuBar1 = new javax.swing.JMenuBar();
        jMenu1 = new javax.swing.JMenu();
        informationMenuItem = new javax.swing.JMenuItem();
        jSeparator4 = new javax.swing.JPopupMenu.Separator();
        quitMenuItem = new javax.swing.JMenuItem();

        setDefaultCloseOperation(DISPOSE_ON_CLOSE);
        setTitle("MediPath");
        setIconImage(getIconImage());

        principalMenuPanel.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(204, 204, 204)));
        principalMenuPanel.setMaximumSize(new java.awt.Dimension(403, 603));
        principalMenuPanel.setMinimumSize(new java.awt.Dimension(403, 603));

        logoLabel.setIcon(new javax.swing.ImageIcon(getClass().getResource("/logomedipath.png"))); // NOI18N
        logoLabel.setAlignmentX(CENTER_ALIGNMENT);

        chargementMenuPanel.setLayout(new java.awt.GridLayout(2, 0, 20, 0));

        adjacenceListButton.setText("Charger liste d'adjacence ...");
        adjacenceListButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                adjacenceListButtonActionPerformed(evt);
            }
        });
        chargementMenuPanel.add(adjacenceListButton);

        voisinListButton.setText("Charger liste des voisins ...");
        voisinListButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                voisinListButtonActionPerformed(evt);
            }
        });
        chargementMenuPanel.add(voisinListButton);

        adjacenceListStatusLabel.setForeground(new java.awt.Color(255, 0, 0));
        adjacenceListStatusLabel.setText("Pas de liste d'adjacence");
        chargementMenuPanel.add(adjacenceListStatusLabel);

        voisinListStatusLabel.setForeground(new java.awt.Color(255, 0, 0));
        voisinListStatusLabel.setText("Pas de liste des voisins");
        chargementMenuPanel.add(voisinListStatusLabel);

        grapheCreationButton.setFont(new java.awt.Font("Tahoma", 1, 10)); // NOI18N
        grapheCreationButton.setForeground(new java.awt.Color(255, 51, 255));
        grapheCreationButton.setText("Créer un graphe");
        grapheCreationButton.setEnabled(false);
        grapheCreationButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                grapheCreationButtonActionPerformed(evt);
            }
        });

        editFilePanel.setLayout(new java.awt.GridLayout(2, 0, 0, 4));

        editAdjacenceFileButton.setText("Modifier la liste d'adjacence par fichier");
        editAdjacenceFileButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                editAdjacenceFileButtonActionPerformed(evt);
            }
        });
        editFilePanel.add(editAdjacenceFileButton);

        editVoisinFileButton.setText("Modifier les centres/voisins par fichier");
        editVoisinFileButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                editVoisinFileButtonActionPerformed(evt);
            }
        });
        editFilePanel.add(editVoisinFileButton);

        editPanel.setLayout(new java.awt.GridLayout(3, 2, 3, 4));

        addCentreButton.setText("Ajouter un centre");
        addCentreButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                addCentreButtonActionPerformed(evt);
            }
        });
        editPanel.add(addCentreButton);

        addRouteButton.setText("Ajouter une route");
        addRouteButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                addRouteButtonActionPerformed(evt);
            }
        });
        editPanel.add(addRouteButton);

        editCentreButton.setText("Modifier un centre");
        editCentreButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                editCentreButtonActionPerformed(evt);
            }
        });
        editPanel.add(editCentreButton);

        editRouteButton.setText("Modifier une route");
        editRouteButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                editRouteButtonActionPerformed(evt);
            }
        });
        editPanel.add(editRouteButton);

        deleteCentreButton.setText("Supprimer un centre");
        deleteCentreButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                deleteCentreButtonActionPerformed(evt);
            }
        });
        editPanel.add(deleteCentreButton);

        deleteRouteButton.setText("Supprimer une route");
        deleteRouteButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                deleteRouteButtonActionPerformed(evt);
            }
        });
        editPanel.add(deleteRouteButton);

        listPanel.setLayout(new java.awt.GridLayout(1, 0, 3, 0));

        centreListButton.setText("Liste des centres");
        centreListButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                centreListButtonActionPerformed(evt);
            }
        });
        listPanel.add(centreListButton);

        routeListButton.setText("Liste des routes");
        routeListButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                routeListButtonActionPerformed(evt);
            }
        });
        listPanel.add(routeListButton);

        infoGrapheButton.setText("Info. Graphe");
        infoGrapheButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                infoGrapheButtonActionPerformed(evt);
            }
        });

        routesParFiabiliteButton.setText("Routes par fiabilité");
        routesParFiabiliteButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                routesParFiabiliteButtonActionPerformed(evt);
            }
        });

        centreParTypeButton.setText("Centres par type");
        centreParTypeButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                centreParTypeButtonActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout grapheMenuPanelLayout = new javax.swing.GroupLayout(grapheMenuPanel);
        grapheMenuPanel.setLayout(grapheMenuPanelLayout);
        grapheMenuPanelLayout.setHorizontalGroup(
            grapheMenuPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jSeparator1, javax.swing.GroupLayout.Alignment.TRAILING)
            .addComponent(jSeparator2, javax.swing.GroupLayout.Alignment.TRAILING)
            .addGroup(grapheMenuPanelLayout.createSequentialGroup()
                .addGap(139, 139, 139)
                .addComponent(grapheCreationButton)
                .addGap(0, 0, Short.MAX_VALUE))
            .addGroup(grapheMenuPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(grapheMenuPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(editPanel, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, grapheMenuPanelLayout.createSequentialGroup()
                        .addGap(0, 0, Short.MAX_VALUE)
                        .addComponent(chargementMenuPanel, javax.swing.GroupLayout.PREFERRED_SIZE, 380, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addComponent(editFilePanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jSeparator3, javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(listPanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addContainerGap())
            .addGroup(grapheMenuPanelLayout.createSequentialGroup()
                .addGap(125, 125, 125)
                .addGroup(grapheMenuPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(infoGrapheButton, javax.swing.GroupLayout.DEFAULT_SIZE, 163, Short.MAX_VALUE)
                    .addComponent(routesParFiabiliteButton, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(centreParTypeButton, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        grapheMenuPanelLayout.setVerticalGroup(
            grapheMenuPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(grapheMenuPanelLayout.createSequentialGroup()
                .addGap(18, 18, 18)
                .addComponent(chargementMenuPanel, javax.swing.GroupLayout.PREFERRED_SIZE, 66, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(2, 2, 2)
                .addComponent(grapheCreationButton, javax.swing.GroupLayout.PREFERRED_SIZE, 42, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jSeparator1, javax.swing.GroupLayout.PREFERRED_SIZE, 6, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(editFilePanel, javax.swing.GroupLayout.PREFERRED_SIZE, 59, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addComponent(jSeparator2, javax.swing.GroupLayout.PREFERRED_SIZE, 10, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(editPanel, javax.swing.GroupLayout.PREFERRED_SIZE, 80, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addComponent(jSeparator3, javax.swing.GroupLayout.PREFERRED_SIZE, 10, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(listPanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addComponent(infoGrapheButton)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(routesParFiabiliteButton)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(centreParTypeButton)
                .addContainerGap(114, Short.MAX_VALUE))
        );

        menuTabbedPane.addTab("Graphe", grapheMenuPanel);

        jPanel3.setLayout(new java.awt.GridLayout(5, 0));

        cheminPlusCourtDistanceButton.setText("Chemin le plus court en distance");
        cheminPlusCourtDistanceButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                cheminPlusCourtDistanceButtonActionPerformed(evt);
            }
        });
        jPanel3.add(cheminPlusCourtDistanceButton);

        cheminPlusCourtDureeButton.setText("Chemin le plus court en durée");
        cheminPlusCourtDureeButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                cheminPlusCourtDureeButtonActionPerformed(evt);
            }
        });
        jPanel3.add(cheminPlusCourtDureeButton);

        cheminPlusFiableButton1.setText("Chemin le plus fiable");
        cheminPlusFiableButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                cheminPlusFiableButton1ActionPerformed(evt);
            }
        });
        jPanel3.add(cheminPlusFiableButton1);

        jLabel1.setText("Complexité du l'algo. du chemin le plus fiable:");
        jPanel3.add(jLabel1);

        jLabel2.setText("O((NombreDeCentres + NombreDeRoutes) log NombreDeCentres)");
        jPanel3.add(jLabel2);

        javax.swing.GroupLayout cheminMenuPanelLayout = new javax.swing.GroupLayout(cheminMenuPanel);
        cheminMenuPanel.setLayout(cheminMenuPanelLayout);
        cheminMenuPanelLayout.setHorizontalGroup(
            cheminMenuPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(cheminMenuPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jPanel3, javax.swing.GroupLayout.DEFAULT_SIZE, 379, Short.MAX_VALUE)
                .addContainerGap())
        );
        cheminMenuPanelLayout.setVerticalGroup(
            cheminMenuPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(cheminMenuPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jPanel3, javax.swing.GroupLayout.PREFERRED_SIZE, 145, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(431, Short.MAX_VALUE))
        );

        menuTabbedPane.addTab("Chemins", cheminMenuPanel);

        jPanel2.setLayout(new java.awt.GridLayout(5, 1, 0, 4));

        listVoisinButton.setText("Voir les voisins d'un centre");
        listVoisinButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                listVoisinButtonActionPerformed(evt);
            }
        });
        jPanel2.add(listVoisinButton);

        listVoisinTypeButton.setText("Voir les voisins par type");
        listVoisinTypeButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                listVoisinTypeButtonActionPerformed(evt);
            }
        });
        jPanel2.add(listVoisinTypeButton);

        listVoisin2CentreTypeButton.setText("Voir les voisins de 2 centres");
        listVoisin2CentreTypeButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                listVoisin2CentreTypeButtonActionPerformed(evt);
            }
        });
        jPanel2.add(listVoisin2CentreTypeButton);

        voisin2DistancesOuNonButton.setText("Voisin à 2-distances ou non");
        voisin2DistancesOuNonButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                voisin2DistancesOuNonButtonActionPerformed(evt);
            }
        });
        jPanel2.add(voisin2DistancesOuNonButton);

        compare2CentresButton.setText("Comparer deux villes");
        compare2CentresButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                compare2CentresButtonActionPerformed(evt);
            }
        });
        jPanel2.add(compare2CentresButton);

        javax.swing.GroupLayout voisinagePanelLayout = new javax.swing.GroupLayout(voisinagePanel);
        voisinagePanel.setLayout(voisinagePanelLayout);
        voisinagePanelLayout.setHorizontalGroup(
            voisinagePanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(voisinagePanelLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jPanel2, javax.swing.GroupLayout.DEFAULT_SIZE, 379, Short.MAX_VALUE)
                .addContainerGap())
        );
        voisinagePanelLayout.setVerticalGroup(
            voisinagePanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(voisinagePanelLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jPanel2, javax.swing.GroupLayout.PREFERRED_SIZE, 158, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(418, Short.MAX_VALUE))
        );

        menuTabbedPane.addTab("Voisinage", voisinagePanel);

        jLabel3.setText("Légende :");

        typePanel.setLayout(new java.awt.GridLayout(1, 0));

        jLabel4.setForeground(new java.awt.Color(255, 102, 153));
        jLabel4.setText("Maternité (M)");
        typePanel.add(jLabel4);

        jLabel5.setForeground(new java.awt.Color(153, 153, 255));
        jLabel5.setText("Bloc Opératoire (O)");
        typePanel.add(jLabel5);

        jLabel6.setForeground(new java.awt.Color(204, 102, 255));
        jLabel6.setText("Centre de Nutrition (N)");
        typePanel.add(jLabel6);

        javax.swing.GroupLayout legendePanelLayout = new javax.swing.GroupLayout(legendePanel);
        legendePanel.setLayout(legendePanelLayout);
        legendePanelLayout.setHorizontalGroup(
            legendePanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(legendePanelLayout.createSequentialGroup()
                .addGap(22, 22, 22)
                .addGroup(legendePanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jLabel3, javax.swing.GroupLayout.PREFERRED_SIZE, 114, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(typePanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        legendePanelLayout.setVerticalGroup(
            legendePanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(legendePanelLayout.createSequentialGroup()
                .addGap(12, 12, 12)
                .addComponent(jLabel3)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(typePanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(18, Short.MAX_VALUE))
        );

        javax.swing.GroupLayout principalMenuPanelLayout = new javax.swing.GroupLayout(principalMenuPanel);
        principalMenuPanel.setLayout(principalMenuPanelLayout);
        principalMenuPanelLayout.setHorizontalGroup(
            principalMenuPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(principalMenuPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(principalMenuPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, principalMenuPanelLayout.createSequentialGroup()
                        .addComponent(legendePanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addContainerGap())
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, principalMenuPanelLayout.createSequentialGroup()
                        .addGap(0, 0, Short.MAX_VALUE)
                        .addGroup(principalMenuPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, principalMenuPanelLayout.createSequentialGroup()
                                .addComponent(menuTabbedPane, javax.swing.GroupLayout.PREFERRED_SIZE, 404, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addGap(10, 10, 10))
                            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, principalMenuPanelLayout.createSequentialGroup()
                                .addComponent(logoLabel)
                                .addGap(99, 99, 99))))))
        );
        principalMenuPanelLayout.setVerticalGroup(
            principalMenuPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(principalMenuPanelLayout.createSequentialGroup()
                .addGap(4, 4, 4)
                .addComponent(logoLabel)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(menuTabbedPane)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(legendePanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );

        getContentPane().add(principalMenuPanel, java.awt.BorderLayout.LINE_END);
        principalMenuPanel.getAccessibleContext().setAccessibleName("");

        graphPanel.addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
            public void mouseDragged(java.awt.event.MouseEvent evt) {
                graphPanelMouseDragged(evt);
            }
        });
        graphPanel.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mousePressed(java.awt.event.MouseEvent evt) {
                graphPanelMousePressed(evt);
            }
            public void mouseReleased(java.awt.event.MouseEvent evt) {
                graphPanelMouseReleased(evt);
            }
        });
        graphPanel.addComponentListener(new java.awt.event.ComponentAdapter() {
            public void componentResized(java.awt.event.ComponentEvent evt) {
                graphPanelComponentResized(evt);
            }
        });

        javax.swing.GroupLayout graphPanelLayout = new javax.swing.GroupLayout(graphPanel);
        graphPanel.setLayout(graphPanelLayout);
        graphPanelLayout.setHorizontalGroup(
            graphPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 1062, Short.MAX_VALUE)
        );
        graphPanelLayout.setVerticalGroup(
            graphPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 775, Short.MAX_VALUE)
        );

        getContentPane().add(graphPanel, java.awt.BorderLayout.CENTER);

        jMenu1.setText("Menu");

        informationMenuItem.setText("Informations");
        informationMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                informationMenuItemActionPerformed(evt);
            }
        });
        jMenu1.add(informationMenuItem);
        jMenu1.add(jSeparator4);

        quitMenuItem.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_Q, java.awt.event.InputEvent.CTRL_DOWN_MASK));
        quitMenuItem.setText("Quitter");
        quitMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                quitMenuItemActionPerformed(evt);
            }
        });
        jMenu1.add(quitMenuItem);

        jMenuBar1.add(jMenu1);

        setJMenuBar(jMenuBar1);

        pack();
    }// </editor-fold>//GEN-END:initComponents
    /**
     * Action exécutée lorsque le bouton "Adjacence List" est cliqué.
     */
    private void adjacenceListButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_adjacenceListButtonActionPerformed
        try {
            // Création d'un JFileChooser
            JFileChooser adjacenceFileChooser = new JFileChooser("./");
            adjacenceFileChooser.setDialogTitle("Select a csv");
            adjacenceFileChooser.setAcceptAllFileFilterUsed(false);
            FileNameExtensionFilter filter = new FileNameExtensionFilter("Graphe file", "txt", "text", "csv");
            adjacenceFileChooser.setFileFilter(filter);

            // Vérification si un fichier a été sélectionné
            if (adjacenceFileChooser.showOpenDialog(null) == JFileChooser.APPROVE_OPTION) {

                // Obtention de l'adresse du fichier
                this.adjacenceFilePath = adjacenceFileChooser.getSelectedFile().getAbsolutePath();
                adjacenceListStatusLabel.setText("Liste de'adjacence sélectionnée");
                adjacenceListStatusLabel.setForeground(Color.green);

                // Utilisation de l'adresse du fichier (à titre d'exemple, nous l'imprimons ici)
                System.out.println("Fichier sélectionné : " + this.adjacenceFilePath);

                if (fichiersChoisis == true) {
                    grapheCreationButton.setEnabled(true);
                }

                fichiersChoisis = true;
            }
        } catch (Exception ex) {
            // Gestion des exceptions
            ex.printStackTrace();
        }
    }//GEN-LAST:event_adjacenceListButtonActionPerformed

    /**
     * Action exécutée lorsque le bouton "Voisin List" est cliqué.
     */
    private void voisinListButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_voisinListButtonActionPerformed
        try {
            // Création d'un JFileChooser
            JFileChooser voisinFileChooser = new JFileChooser("./");
            voisinFileChooser.setDialogTitle("Select a csv");
            voisinFileChooser.setAcceptAllFileFilterUsed(false);
            FileNameExtensionFilter filter = new FileNameExtensionFilter("Graphe file", "txt", "text", "csv");
            voisinFileChooser.setFileFilter(filter);

            // Vérification si un fichier a été sélectionné
            if (voisinFileChooser.showOpenDialog(null) == JFileChooser.APPROVE_OPTION) {
                // Obtention de l'adresse du fichier
                this.voisinFilePath = voisinFileChooser.getSelectedFile().getAbsolutePath();
                File file = new File(voisinFilePath);

                // Vérifie si le fichier peut être lu
                if (!file.canRead()) {
                    JOptionPane.showMessageDialog(null, "Le fichier ne peut pas être lu. Veuillez choisir un autre fichier.", "Erreur", JOptionPane.ERROR_MESSAGE);
                    return;
                }

                // Vérifie si le fichier est dans le bon format (csv)
                if (!voisinFilePath.endsWith(".csv")) {
                    JOptionPane.showMessageDialog(null, "Le format du fichier est incorrect. Veuillez choisir un fichier .csv.", "Erreur", JOptionPane.ERROR_MESSAGE);
                    return;
                }

                voisinListStatusLabel.setText("Liste des voisins sélectionnée");
                voisinListStatusLabel.setForeground(Color.green);

                // Utilisation de l'adresse du fichier (à titre d'exemple, nous l'imprimons ici)
                System.out.println("Fichier sélectionné : " + voisinFilePath);

                if (fichiersChoisis == true) {
                    grapheCreationButton.setEnabled(true);
                }

                fichiersChoisis = true;
            }
        } catch (Exception ex) {
            ex.printStackTrace();
            JOptionPane.showMessageDialog(null, "Une erreur inattendue s'est produite. Veuillez réessayer.", "Erreur", JOptionPane.ERROR_MESSAGE);
        }
    }//GEN-LAST:event_voisinListButtonActionPerformed

    /**
     * Action exécutée lorsque le bouton "Graphe Creation" est cliqué.
     */
    private void grapheCreationButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_grapheCreationButtonActionPerformed
        clearGraph();
        graphe.remplirGrapheViaFichier(this.adjacenceFilePath, this.voisinFilePath);

        assignPositions();
        drawGraph();
    }//GEN-LAST:event_grapheCreationButtonActionPerformed

    /**
     * Action exécutée lorsque la souris est enfoncée dans le graphique.
     */
    private void graphPanelMousePressed(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_graphPanelMousePressed
        for (CentreDeSante centre : points.keySet()) {
            if (points.get(centre).contains(evt.getPoint())) {
                draggedCentre = centre;
                break;
            }
        }
    }//GEN-LAST:event_graphPanelMousePressed

    /**
     * Action exécutée lorsque le composant graphPanel est redimensionné.
     */
    private void graphPanelComponentResized(java.awt.event.ComponentEvent evt) {//GEN-FIRST:event_graphPanelComponentResized
        drawGraph();
    }//GEN-LAST:event_graphPanelComponentResized

    /**
     * Action exécutée lorsque le bouton de la souris est relâché dans le
     * graphique.
     */
    private void graphPanelMouseReleased(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_graphPanelMouseReleased
        draggedCentre = null;
    }//GEN-LAST:event_graphPanelMouseReleased

    /**
     * Action exécutée lorsque la souris est déplacée dans le graphique.
     */
    private void graphPanelMouseDragged(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_graphPanelMouseDragged
        if (draggedCentre != null) {
            int x = evt.getX() - points.get(draggedCentre).width / 2;
            int y = evt.getY() - points.get(draggedCentre).height / 2;
            points.put(draggedCentre, new Rectangle(x, y, points.get(draggedCentre).width, points.get(draggedCentre).height));

            drawRoutes();
            drawGraph();
        }
    }//GEN-LAST:event_graphPanelMouseDragged

    /**
     * Action exécutée lorsque le bouton "Edit Adjacence File" est cliqué.
     * Permet d'ouvrir le fichier d'adjacence sélectionné pour l'édition.
     */
    private void editAdjacenceFileButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_editAdjacenceFileButtonActionPerformed
        try {
            if (this.adjacenceFilePath != null && !this.adjacenceFilePath.equals("")) {
                // Vérifie si le bureau est supporté par la Plateforme
                if (!Desktop.isDesktopSupported()) {
                    System.out.println("Desktop is not supported");
                    return;
                }

                Desktop desktop = Desktop.getDesktop();
                if (!desktop.isSupported(Desktop.Action.EDIT)) {
                    System.out.println("EDIT is not supported");
                    return;
                }

                // Ouvre le fichier pour l'édition
                desktop.edit(new File(this.adjacenceFilePath));

            } else {
                JOptionPane.showMessageDialog(null, "Aucun fichier d'adjacence sélectionné. Veuillez d'abord choisir un fichier.", "Erreur", JOptionPane.ERROR_MESSAGE);
            }
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }//GEN-LAST:event_editAdjacenceFileButtonActionPerformed

    /**
     * Action exécutée lorsque le bouton "Edit Voisin File" est cliqué. Permet
     * d'ouvrir le fichier des voisins sélectionné pour l'édition.
     */
    private void editVoisinFileButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_editVoisinFileButtonActionPerformed
        try {
            if (this.voisinFilePath != null && !this.voisinFilePath.equals("")) {
                // Vérifie si le bureau est supporté par la Plateforme
                if (!Desktop.isDesktopSupported()) {
                    System.out.println("Desktop is not supported");
                    return;
                }

                Desktop desktop = Desktop.getDesktop();
                if (!desktop.isSupported(Desktop.Action.EDIT)) {
                    System.out.println("EDIT is not supported");
                    return;
                }

                // Ouvre le fichier pour l'édition
                desktop.edit(new File(this.voisinFilePath));

            } else {
                JOptionPane.showMessageDialog(null, "Aucun fichier de voisin sélectionné. Veuillez d'abord choisir un fichier.", "Erreur", JOptionPane.ERROR_MESSAGE);
            }
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }//GEN-LAST:event_editVoisinFileButtonActionPerformed

    /**
     * Action exécutée lorsque le bouton "Centre List" est cliqué. Affiche une
     * liste des centres de santé créés dans le graphe.
     */
    private void centreListButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_centreListButtonActionPerformed
        // Vérifie si un graphe a été créé
        if (graphe == null) {
            JOptionPane.showMessageDialog(null, "Aucun graphe n'a été créé. Veuillez d'abord créer un graphe.", "Erreur", JOptionPane.ERROR_MESSAGE);
            return;
        }

        // Récupère la liste des centres de santé
        ArrayList<CentreDeSante> centreList = graphe.getCentreDeSanteList();

        // Vérifie si la liste des centres de santé est vide
        if (centreList.isEmpty()) {
            System.out.println("La liste des centres de santé est vide.");
            JOptionPane.showMessageDialog(null, "La liste des centres de santé est vide.", "Erreur", JOptionPane.ERROR_MESSAGE);
            return;
        }

        // Tri la liste des centres de santé par ID (ordre alphabétique)
        centreList.sort(Comparator.comparing(CentreDeSante::getType));

        // Crée un modèle de tableau pour contenir les informations des centres de santé
        DefaultTableModel model = new DefaultTableModel() {
            @Override
            public boolean isCellEditable(int row, int column) {
                // Toutes les cellules sont non modifiables
                return false;
            }
        };
        model.addColumn("ID");
        model.addColumn("Type");

        // Ajoute les informations de chaque centre de santé au modèle de tableau
        for (CentreDeSante centre : centreList) {
            String id = centre.getId();
            String type = centre.getType();

            // Ajoute les informations du centre de santé au modèle de tableau
            model.addRow(new Object[]{
                id,
                type
            });
        }

        // Crée une nouvelle JFrame
        JFrame frame = new JFrame("Liste des Centres de Santé");
        frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);  // ferme la fenêtre lorsque l'utilisateur clique sur le bouton de fermeture

        // Crée un nouveau JTable à partir du modèle et l'ajoute à la JFrame
        JTable table = new JTable(model);
        JScrollPane scrollPane = new JScrollPane(table);
        frame.add(scrollPane, BorderLayout.CENTER);

        // Affiche la JFrame
        frame.pack();
        frame.setVisible(true);
    }//GEN-LAST:event_centreListButtonActionPerformed

    /**
     * Action exécutée lorsque le bouton "Route List" est cliqué. Affiche une
     * liste des routes présentes dans le graphe.
     */
    private void routeListButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_routeListButtonActionPerformed
        // Vérifie si un graphe a été créé
        if (graphe == null) {
            JOptionPane.showMessageDialog(null, "Aucun graphe n'a été créé. Veuillez d'abord créer un graphe.", "Erreur", JOptionPane.ERROR_MESSAGE);
            return;
        }

        // Récupère la liste des routes
        HashMap<CentreDeSante, ArrayList<Route>> routesMap = graphe.getRoutesMap();

        // Vérifie si la liste des routes est vide
        if (routesMap.isEmpty()) {
            System.out.println("La liste des routes est vide.");
            JOptionPane.showMessageDialog(null, "La liste des routes est vide.", "Erreur", JOptionPane.ERROR_MESSAGE);
            return;
        }

        // Crée une liste des centres de santé triée par l'ID du centre
        // Crée une liste des centres de santé triée
        List<CentreDeSante> sortedCentres = new ArrayList<>(routesMap.keySet());
        sortedCentres.sort((centre1, centre2) -> {
            String id1 = centre1.getId();
            String id2 = centre2.getId();

            // Si les deux ID commencent par "S", compare les parties numériques
            if (id1.startsWith("S") && id2.startsWith("S")) {
                return Integer.compare(
                        Integer.parseInt(id1.substring(1)),
                        Integer.parseInt(id2.substring(1))
                );
            } // Sinon, compare les ID complets
            else {
                return id1.compareTo(id2);
            }
        });

        // Crée un modèle de tableau pour contenir les informations des routes
        DefaultTableModel model = new DefaultTableModel() {
            @Override
            public boolean isCellEditable(int row, int column) {
                // Toutes les cellules sont non modifiables
                return false;
            }
        };
        model.addColumn("Départ");
        model.addColumn("Destination");
        model.addColumn("Distance");
        model.addColumn("Durée Moyenne");
        model.addColumn("Fiabilité");

        // Ajoute les informations de chaque route au modèle de tableau
        for (CentreDeSante depart : sortedCentres) {
            ArrayList<Route> routes = routesMap.get(depart);

            for (Route route : routes) {
                CentreDeSante destination = route.getDestination();
                double fiabilite = route.getFiabilite();
                int distance = route.getDistance();
                int dureeMoyenne = route.getDureeMoyenne();

                // Vérifie si la destination de la route est null
                if (destination == null) {
                    System.out.println("La destination de la route est null.");
                }

                // Ajoute les informations de la route au modèle de tableau
                model.addRow(new Object[]{
                    depart != null ? depart.getId() : "null",
                    destination != null ? destination.getId() : "null",
                    distance,
                    dureeMoyenne,
                    fiabilite
                });
            }
        }

        // Crée une nouvelle JFrame
        JFrame frame = new JFrame("Liste des Routes");
        frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);  // ferme la fenêtre lorsque l'utilisateur clique sur le bouton de fermeture

        // Crée un nouveau JTable à partir du modèle et l'ajoute à la JFrame
        JTable table = new JTable(model);
        JScrollPane scrollPane = new JScrollPane(table);
        frame.add(scrollPane, BorderLayout.CENTER);

        // Affiche la JFrame
        frame.pack();
        frame.setVisible(true);
    }//GEN-LAST:event_routeListButtonActionPerformed

    /**
     * Crée une nouvelle instance de graphe.
     */
    public void createGrapheInstance() {
        graphe = new Graphe();
    }

    /**
     * Retourne le graphe.
     *
     * @return graphe
     */
    public Graphe getGraphe() {
        return this.graphe;
    }

    /**
     * Assigner des positions aléatoires aux centres de santé sur le panneau
     * graphique.
     */
    private void assignPositions() {
        if (graphe != null) {
            Random random = new Random();
            Collection<CentreDeSante> centres = graphe.getCentreDeSanteList();

            int pointSize = 30;

            for (CentreDeSante centre : centres) {
                int x = pointSize + random.nextInt(graphPanel.getWidth() - 2 * pointSize);  // generate a random x position
                int y = pointSize + random.nextInt(graphPanel.getHeight() - 2 * pointSize); // generate a random y position

                points.put(centre, new Rectangle(x, y, pointSize, pointSize));
            }
        }
    }

    /**
     * Dessine le graphe sur le panneau graphique.
     */
    private void drawGraph() {
        Graphics g = graphPanel.getGraphics();
        Graphics2D g2d = (Graphics2D) g;

        g.clearRect(0, 0, graphPanel.getWidth(), graphPanel.getHeight());

        drawRoutes();
        if (graphe != null) {
            g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
            g2d.setFont(new Font("default", Font.BOLD, 14)); // ajuste la taille de la police

            Collection<CentreDeSante> centres = graphe.getCentreDeSanteList();

            for (CentreDeSante centre : centres) {
                Rectangle point = points.get(centre);

                switch (centre.getType()) {
                    case "M":
                        g2d.setColor(new Color(255, 105, 180)); // définir en rose
                        break;
                    case "N":
                        g2d.setColor(new Color(221, 160, 221)); // définir en violet clair
                        break;
                    case "O":
                        g2d.setColor(new Color(173, 216, 230)); // définir en bleu clair
                        break;
                    default:
                        g2d.setColor(Color.BLACK); // par défaut, définir en noir
                        break;
                }

                g2d.fillOval(point.x, point.y, point.width, point.height); // dessine le point

                // Dessine l'ID à l'intérieur du cercle
                g2d.setColor(Color.WHITE); // définir la couleur en blanc pour la visibilité
                g2d.drawString(String.valueOf(centre.getId()), point.x + point.width / 2 - g2d.getFontMetrics().stringWidth(String.valueOf(centre.getId())) / 2, point.y + (point.height + 10) / 2);
            }
        }
    }

    /**
     * Dessine les routes sur le panneau graphique.
     */
    private void drawRoutes() {
        Graphics g = graphPanel.getGraphics();
        Graphics2D g2d = (Graphics2D) g;
        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);

        for (CentreDeSante centre : graphe.getCentreDeSanteList()) {
            Rectangle rectCentre = points.get(centre);

            ArrayList<Route> routes = graphe.getRoutes(centre);
            for (Route route : routes) {
                CentreDeSante destination = route.getDestination();
                Rectangle rectDest = points.get(destination);

                g2d.setColor(Color.BLACK);
                g2d.drawLine(rectCentre.x + rectCentre.width / 2, rectCentre.y + rectCentre.height / 2,
                        rectDest.x + rectDest.width / 2, rectDest.y + rectDest.height / 2);
            }
        }
    }

    /**
     * Efface le graphe affiché sur le panneau graphique.
     */
    private void clearGraph() {
        graphe = new Graphe();
        Graphics g = graphPanel.getGraphics();
        g.clearRect(0, 0, graphPanel.getWidth(), graphPanel.getHeight());
        points.clear(); // Also clear the points map
    }

    /**
     * Affiche les informations générales sur le graphe, y compris le nombre
     * total de centres de santé, le nombre de centres de santé par type et le
     * nombre total de routes.
     */
    private void infoGrapheButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_infoGrapheButtonActionPerformed
        if (graphe == null) {
            JOptionPane.showMessageDialog(null, "Aucun graphe n'a été créé. Veuillez d'abord créer un graphe.", "Erreur", JOptionPane.ERROR_MESSAGE);
            return;
        }

        ArrayList<CentreDeSante> centreList = graphe.getCentreDeSanteList();
        HashMap<CentreDeSante, ArrayList<Route>> routesMap = graphe.getRoutesMap();

        if (centreList.isEmpty()) {
            JOptionPane.showMessageDialog(null, "Il n'y a pas de centres de santé.", "Erreur", JOptionPane.ERROR_MESSAGE);
            return;
        }

        Map<String, Long> countByType = centreList.stream().collect(Collectors.groupingBy(CentreDeSante::getType, Collectors.counting()));

        String message = "Nombre total de centres de santé: " + centreList.size() + "\n";
        for (Map.Entry<String, Long> entry : countByType.entrySet()) {
            message += "Nombre de centres de santé de type " + entry.getKey() + ": " + entry.getValue() + "\n";
        }

        int totalRoutes = 0;
        for (Map.Entry<CentreDeSante, ArrayList<Route>> entry : routesMap.entrySet()) {
            totalRoutes += entry.getValue().size();
        }
        message += "Nombre total de routes: " + (totalRoutes / 2);

        JOptionPane.showMessageDialog(null, message, "Résumé", JOptionPane.INFORMATION_MESSAGE);
    }//GEN-LAST:event_infoGrapheButtonActionPerformed

    /**
     * Quitte l'application en fermant la fenêtre principale.
     */
    private void quitMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_quitMenuItemActionPerformed
        dispose();
    }//GEN-LAST:event_quitMenuItemActionPerformed

    /**
     * Ajoute un nouveau centre de santé au graphe.
     */
    private void addCentreButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_addCentreButtonActionPerformed

        if (graphe == null) {
            JOptionPane.showMessageDialog(null, "Aucun graphe n'a été créé. Veuillez d'abord créer un graphe.", "Erreur", JOptionPane.ERROR_MESSAGE);
            return;
        }

        try {
            // Demander à l'utilisateur d'entrer les détails du nouveau centre
            String id = JOptionPane.showInputDialog(null, "Entrez l'ID du nouveau centre de santé:", "Ajouter un centre de santé", JOptionPane.QUESTION_MESSAGE);
            if (id == null || id.trim().isEmpty()) {
                JOptionPane.showMessageDialog(null, "L'ID du centre de santé ne peut pas être vide.", "Erreur", JOptionPane.ERROR_MESSAGE);
                return;
            }

            String type = JOptionPane.showInputDialog(null, "Entrez le type du nouveau centre de santé:", "Ajouter un centre de santé", JOptionPane.QUESTION_MESSAGE);
            if (type == null || type.trim().isEmpty()) {
                JOptionPane.showMessageDialog(null, "Le type du centre de santé ne peut pas être vide.", "Erreur", JOptionPane.ERROR_MESSAGE);
                return;
            }

            // Créer un nouveau centre de santé avec les détails entrés
            graphe.addCentreDeSante(id, type);

            // Redessiner le graphe
            assignPositions();
            drawGraph();
        } catch (NumberFormatException e) {
            JOptionPane.showMessageDialog(null, "Veuillez saisir des valeurs numériques valides.", "Erreur de format", JOptionPane.ERROR_MESSAGE);
        }
    }//GEN-LAST:event_addCentreButtonActionPerformed

    /**
     * Modifie le type d'un centre de santé existant.
     */
    private void editCentreButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_editCentreButtonActionPerformed
        // Vérifie si un graphe a été créé
        if (graphe == null) {
            JOptionPane.showMessageDialog(null, "Aucun graphe n'a été créé. Veuillez d'abord créer un graphe.", "Erreur", JOptionPane.ERROR_MESSAGE);
            return;
        }

        // Obtenir tous les sommets
        ArrayList<CentreDeSante> allCentres = new ArrayList<>(graphe.getRoutesMap().keySet());

        // Vérifie si la liste est vide
        if (allCentres.isEmpty()) {
            JOptionPane.showMessageDialog(null, "Il n'y a pas de centres de santé dans le graphe.", "Erreur", JOptionPane.ERROR_MESSAGE);
            return;
        }

        // Trie la liste des centres de santé en utilisant la valeur numérique qui suit le "S" dans l'ID du centre
        allCentres.sort(Comparator.comparing(c -> Integer.parseInt(c.getId().substring(1))));

        // Demander à l'utilisateur de sélectionner le premier sommet
        CentreDeSante centre = (CentreDeSante) JOptionPane.showInputDialog(null, "Choisissez le centre de santé à modifier:", "Modifier un centre de santé", JOptionPane.QUESTION_MESSAGE, null, allCentres.toArray(), allCentres.get(0));
        if (centre == null) {
            // L'utilisateur a annulé la sélection
            return;
        }

        // Le centre ne devrait pas être nul à ce stade
        try {
            // Demander à l'utilisateur d'entrer les nouvelles valeurs pour les attributs du centre
            String nouveauType = JOptionPane.showInputDialog(null, "Entrez le nouveau type du centre de santé:", "Modifier un centre de santé", JOptionPane.QUESTION_MESSAGE);

            // Mettre à jour le centre de santé avec les nouvelles valeurs
            centre.setType(nouveauType);

            // Redessiner le graphe
            drawGraph();
        } catch (NumberFormatException e) {
            JOptionPane.showMessageDialog(null, "Veuillez saisir des valeurs numériques valides.", "Erreur de format", JOptionPane.ERROR_MESSAGE);
        }
    }//GEN-LAST:event_editCentreButtonActionPerformed

    /**
     * Supprime un centre de santé du graphe, ainsi que toutes les routes
     * associées.
     */
    private void deleteCentreButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_deleteCentreButtonActionPerformed
        // Vérifie si un graphe a été créé
        if (graphe == null) {
            JOptionPane.showMessageDialog(null, "Aucun graphe n'a été créé. Veuillez d'abord créer un graphe.", "Erreur", JOptionPane.ERROR_MESSAGE);
            return;
        }

        // Obtenir tous les sommets
        ArrayList<CentreDeSante> allCentres = new ArrayList<>(graphe.getRoutesMap().keySet());

        // Vérifie si la liste est vide
        if (allCentres.isEmpty()) {
            JOptionPane.showMessageDialog(null, "Il n'y a pas de centres de santé dans le graphe.", "Erreur", JOptionPane.ERROR_MESSAGE);
            return;
        }

        // Trie la liste des centres de santé en utilisant la valeur numérique qui suit le "S" dans l'ID du centre
        allCentres.sort(Comparator.comparing(c -> Integer.parseInt(c.getId().substring(1))));

        // Demander à l'utilisateur de sélectionner le premier sommet
        CentreDeSante centre = (CentreDeSante) JOptionPane.showInputDialog(null, "Choisissez le centre de santé à supprimer:", "Modifier un centre de santé", JOptionPane.QUESTION_MESSAGE, null, allCentres.toArray(), allCentres.get(0));
        if (centre == null) {
            // L'utilisateur a annulé la sélection
            return;
        }

        // Supprime le centre de santé de la liste de centres de santé du graphe
        graphe.removeCentreDeSante(centre);

        // Supprime toutes les routes associées à ce centre de santé
        graphe.removeRoutes(centre);

        // Redessine le graphe
        drawGraph();
    }//GEN-LAST:event_deleteCentreButtonActionPerformed

    /**
     * Ajoute une nouvelle route entre deux centres de santé existants.
     */
    private void addRouteButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_addRouteButtonActionPerformed
        // Vérifie si un graphe a été créé
        if (graphe == null) {
            JOptionPane.showMessageDialog(null, "Aucun graphe n'a été créé. Veuillez d'abord créer un graphe.", "Erreur", JOptionPane.ERROR_MESSAGE);
            return;
        }

        // Récupère la liste des centres de santé
        List<CentreDeSante> centres = graphe.getCentreDeSanteList();

        // Crée un JComboBox pour les centres de santé de départ et d'arrivée
        JComboBox<CentreDeSante> departComboBox = new JComboBox<>(centres.toArray(new CentreDeSante[0]));
        JComboBox<CentreDeSante> destinationComboBox = new JComboBox<>(centres.toArray(new CentreDeSante[0]));

        // Demande à l'utilisateur de choisir le centre de santé de départ
        JOptionPane.showConfirmDialog(null, departComboBox, "Sélectionnez le centre de santé de départ", JOptionPane.PLAIN_MESSAGE);
        CentreDeSante depart = (CentreDeSante) departComboBox.getSelectedItem();

        // Demande à l'utilisateur de choisir le centre de santé de destination
        JOptionPane.showConfirmDialog(null, destinationComboBox, "Sélectionnez le centre de santé de destination", JOptionPane.PLAIN_MESSAGE);
        CentreDeSante destination = (CentreDeSante) destinationComboBox.getSelectedItem();

        try {
            // Demande à l'utilisateur de saisir la distance de la route
            int distance = Integer.parseInt(JOptionPane.showInputDialog("Entrez la distance de la route (en km) :"));

            // Demande à l'utilisateur de saisir la durée moyenne de la route
            int dureeMoyenne = Integer.parseInt(JOptionPane.showInputDialog("Entrez la durée moyenne de la route (en min) :"));

            // Demande à l'utilisateur de saisir la fiabilité de la route
            double fiabilite = Double.parseDouble(JOptionPane.showInputDialog("Entrez la fiabilité de la route (valeur entre 0 et 100) :"));

            // Crée une nouvelle instance de Route
            Route route = new Route(destination, distance, dureeMoyenne, fiabilite);
            Route routeRetour = new Route(depart, distance, dureeMoyenne, fiabilite);

            // Ajoute la nouvelle route à la liste des routes du graphe
            graphe.addRoute(depart, route);
            graphe.addRoute(destination, routeRetour);

            drawRoutes();
            drawGraph();
        } catch (NumberFormatException e) {
            JOptionPane.showMessageDialog(null, "Veuillez saisir des valeurs numériques valides.", "Erreur de format", JOptionPane.ERROR_MESSAGE);
        }
    }//GEN-LAST:event_addRouteButtonActionPerformed

    /**
     * Permet de modifier les paramètres d'une route existante en
     * double-cliquant sur la ligne correspondante dans le tableau.
     */
    private void editRouteButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_editRouteButtonActionPerformed
        // Vérifie si un graphe a été créé
        if (graphe == null) {
            JOptionPane.showMessageDialog(null, "Aucun graphe n'a été créé. Veuillez d'abord créer un graphe.", "Erreur", JOptionPane.ERROR_MESSAGE);
            return;
        }

        // Récupère la liste des routes
        HashMap<CentreDeSante, ArrayList<Route>> routesMap = graphe.getRoutesMap();

        // Vérifie si la liste des routes est vide
        if (routesMap.isEmpty()) {
            JOptionPane.showMessageDialog(null, "La liste des routes est vide.", "Erreur", JOptionPane.ERROR_MESSAGE);
            return;
        }

        // Crée une liste des centres de santé triée
        List<CentreDeSante> sortedCentres = new ArrayList<>(routesMap.keySet());
        sortedCentres.sort((centre1, centre2) -> {
            String id1 = centre1.getId();
            String id2 = centre2.getId();

            // Si les deux ID commencent par "S", compare les parties numériques
            if (id1.startsWith("S") && id2.startsWith("S")) {
                return Integer.compare(
                        Integer.parseInt(id1.substring(1)),
                        Integer.parseInt(id2.substring(1))
                );
            } // Sinon, compare les ID complets
            else {
                return id1.compareTo(id2);
            }
        });

        // Crée un modèle de tableau pour contenir les informations des routes
        DefaultTableModel model = new DefaultTableModel() {
            @Override
            public boolean isCellEditable(int row, int column) {
                // Toutes les cellules sont non modifiables
                return false;
            }
        };
        model.addColumn("Départ");
        model.addColumn("Id Route");
        model.addColumn("Destination");
        model.addColumn("Distance");
        model.addColumn("Durée Moyenne");
        model.addColumn("Fiabilité");

        for (CentreDeSante depart : sortedCentres) {
            ArrayList<Route> routes = routesMap.get(depart);

            for (Route route : routes) {
                CentreDeSante destination = route.getDestination();
                double fiabilite = route.getFiabilite();
                int distance = route.getDistance();
                int dureeMoyenne = route.getDureeMoyenne();

                model.addRow(new Object[]{
                    depart,
                    route,
                    destination.getId(),
                    distance,
                    dureeMoyenne,
                    fiabilite
                });
            }
        }

        // Crée une nouvelle JFrame
        JFrame frame = new JFrame("Modifier une route");
        frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);

        // Crée un nouveau JTable à partir du modèle et l'ajoute à la JFrame
        JTable table = new JTable(model);

        // Ajoute un écouteur d'événements à la table
        table.addMouseListener(new MouseAdapter() {
            @Override
            public void mousePressed(MouseEvent me) {
                if (me.getClickCount() == 2) {
                    Point p = me.getPoint();
                    int row = table.rowAtPoint(p);

                    CentreDeSante depart = (CentreDeSante) model.getValueAt(row, 0);
                    Route route = (Route) model.getValueAt(row, 1);
                    CentreDeSante arrivee = route.getDestination();

                    try {
                        // Demande à l'utilisateur de modifier les paramètres de la route
                        String newDistanceString = JOptionPane.showInputDialog("Entrez la nouvelle distance pour la route:");
                        int newDistance = Integer.parseInt(newDistanceString);
                        String newDureeMoyenneString = JOptionPane.showInputDialog("Entrez la nouvelle durée moyenne pour la route:");
                        int newDureeMoyenne = Integer.parseInt(newDureeMoyenneString);
                        String newFiabiliteString = JOptionPane.showInputDialog("Entrez la nouvelle fiabilité pour la route:");
                        double newFiabilite = Double.parseDouble(newFiabiliteString);

                        // Met à jour les paramètres de la route
                        route.setDistance(newDistance);
                        route.setDureeMoyenne(newDureeMoyenne);
                        route.setFiabilite(newFiabilite);

                        // Recherche la route de retour (de l'arrivée vers le départ)
                        for (Route backRoute : routesMap.get(arrivee)) {
                            if (backRoute.getDestination().equals(depart)) {
                                // Met à jour les paramètres de la route de retour
                                backRoute.setDistance(newDistance);
                                backRoute.setDureeMoyenne(newDureeMoyenne);
                                backRoute.setFiabilite(newFiabilite);
                                break;
                            }
                        }

                        frame.dispose();
                    } catch (NumberFormatException e) {
                        JOptionPane.showMessageDialog(null, "Veuillez saisir des valeurs numériques valides.", "Erreur de format", JOptionPane.ERROR_MESSAGE);
                    }
                }
            }
        });

        JScrollPane scrollPane = new JScrollPane(table);
        frame.add(scrollPane, BorderLayout.CENTER);

        // Affiche la JFrame
        frame.pack();
        frame.setVisible(true);
    }//GEN-LAST:event_editRouteButtonActionPerformed

    /**
     * Supprime une route existante en double-cliquant sur la ligne
     * correspondante dans le tableau.
     */
    private void deleteRouteButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_deleteRouteButtonActionPerformed
        // Vérifie si un graphe a été créé
        if (graphe == null) {
            JOptionPane.showMessageDialog(null, "Aucun graphe n'a été créé. Veuillez d'abord créer un graphe.", "Erreur", JOptionPane.ERROR_MESSAGE);
            return;
        }

        // Récupère la liste des routes
        HashMap<CentreDeSante, ArrayList<Route>> routesMap = graphe.getRoutesMap();

        // Vérifie si la liste des routes est vide
        if (routesMap.isEmpty()) {
            JOptionPane.showMessageDialog(null, "La liste des routes est vide.", "Erreur", JOptionPane.ERROR_MESSAGE);
            return;
        }

        // Crée une liste des centres de santé triée
        List<CentreDeSante> sortedCentres = new ArrayList<>(routesMap.keySet());
        sortedCentres.sort((centre1, centre2) -> {
            String id1 = centre1.getId();
            String id2 = centre2.getId();

            // Si les deux ID commencent par "S", compare les parties numériques
            if (id1.startsWith("S") && id2.startsWith("S")) {
                return Integer.compare(
                        Integer.parseInt(id1.substring(1)),
                        Integer.parseInt(id2.substring(1))
                );
            } // Sinon, compare les ID complets
            else {
                return id1.compareTo(id2);
            }
        });

        // Crée un modèle de tableau pour contenir les informations des routes
        DefaultTableModel model = new DefaultTableModel() {
            @Override
            public boolean isCellEditable(int row, int column) {
                // Toutes les cellules sont non modifiables
                return false;
            }
        };
        model.addColumn("Départ");
        model.addColumn("Id Route");
        model.addColumn("Destination");
        model.addColumn("Distance");
        model.addColumn("Durée Moyenne");
        model.addColumn("Fiabilité");

        for (CentreDeSante depart : sortedCentres) {
            ArrayList<Route> routes = routesMap.get(depart);

            for (Route route : routes) {
                CentreDeSante destination = route.getDestination();
                double fiabilite = route.getFiabilite();
                int distance = route.getDistance();
                int dureeMoyenne = route.getDureeMoyenne();

                model.addRow(new Object[]{
                    depart,
                    route,
                    destination.getId(),
                    distance,
                    dureeMoyenne,
                    fiabilite
                });
            }
        }

        // Crée une nouvelle JFrame
        JFrame frame = new JFrame("Supprimer une route");
        frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);

        // Crée un nouveau JTable à partir du modèle et l'ajoute à la JFrame
        JTable table = new JTable(model);

        // Ajoute un écouteur d'événements à la table
        table.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseClicked(MouseEvent me) {
                if (me.getClickCount() == 2) {
                    Point p = me.getPoint();
                    int row = table.rowAtPoint(p);

                    CentreDeSante depart = (CentreDeSante) model.getValueAt(row, 0);
                    Route routeToBeRemoved = (Route) model.getValueAt(row, 1);
                    CentreDeSante arrivee = routeToBeRemoved.getDestination();

                    // Demande à l'utilisateur pour confirmation
                    int reply = JOptionPane.showConfirmDialog(null, "Êtes-vous sûr de vouloir supprimer cette route?", "Confirmer la suppression", JOptionPane.YES_NO_OPTION);
                    if (reply == JOptionPane.YES_OPTION) {
                        // Supprime la route de la liste
                        routesMap.get(depart).remove(routeToBeRemoved);

                        // Recherche la route de retour (de l'arrivée vers le départ)
                        for (Route backRoute : routesMap.get(arrivee)) {
                            if (backRoute.getDestination().equals(depart)) {
                                // Supprime la route de retour
                                routesMap.get(arrivee).remove(backRoute);
                                break;
                            }
                        }

                        frame.dispose();
                        // Supprime la ligne de la table
                        model.removeRow(row);
                        drawRoutes();
                        drawGraph();
                    }
                }
            }
        });

        JScrollPane scrollPane = new JScrollPane(table);
        frame.add(scrollPane, BorderLayout.CENTER);

        // Affiche la JFrame
        frame.pack();
        frame.setVisible(true);
    }//GEN-LAST:event_deleteRouteButtonActionPerformed

    /**
     * Affiche la liste des voisins d'un centre de santé sélectionné.
     */
    private void listVoisinButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_listVoisinButtonActionPerformed
        // Vérifie si un graphe a été créé
        if (graphe == null) {
            JOptionPane.showMessageDialog(null, "Aucun graphe n'a été créé. Veuillez d'abord créer un graphe.", "Erreur", JOptionPane.ERROR_MESSAGE);
            return;
        }

        // Vérifie si la liste des routes est vide
        if (graphe.getRoutesMap().isEmpty()) {
            JOptionPane.showMessageDialog(null, "La liste des routes est vide.", "Erreur", JOptionPane.ERROR_MESSAGE);
            return;
        }

        // Crée une liste de tous les centres de santé
        List<CentreDeSante> centres = new ArrayList<>(graphe.getRoutesMap().keySet());
        centres.sort(Comparator.comparing(c -> Integer.parseInt(c.getId().substring(1))));

        // Crée une liste de tous les types de centres de santé possibles
        List<String> types = Arrays.asList("M", "O", "N");

        // Récupère tous les centres de santé
        ArrayList<CentreDeSante> allCentres = graphe.getCentreDeSanteList();

        // Tri la liste des centres de santé en utilisant la valeur numérique qui suit le "S" dans l'ID du centre
        allCentres.sort(Comparator.comparing(c -> Integer.parseInt(c.getId().substring(1))));

        // Demande à l'utilisateur de sélectionner le premier centre de santé
        CentreDeSante centre1 = (CentreDeSante) JOptionPane.showInputDialog(null, "Choisissez le premier centre de santé :", "Sélection du centre de santé", JOptionPane.QUESTION_MESSAGE, null, allCentres.toArray(), allCentres.get(0));
        if (centre1 == null) {
            // L'utilisateur a annulé la sélection
            return;
        }

        // Vérifie si l'utilisateur a sélectionné un centre de santé
        if (centre1 == null) {
            JOptionPane.showMessageDialog(null, "Vous devez choisir un centre de santé.", "Erreur", JOptionPane.ERROR_MESSAGE);
            return;
        }
        // Récupère les voisins du type spécifié
        List<CentreDeSante> voisins = graphe.getVoisin((CentreDeSante) centre1);

        // Vérifie si le centre de santé a des voisins du type spécifié
        if (voisins.isEmpty()) {
            JOptionPane.showMessageDialog(null, "Le centre de santé sélectionné n'a pas de voisins.", "Information", JOptionPane.INFORMATION_MESSAGE);
        } else {
            String message = "Les voisins du centre sont : ";
            for (CentreDeSante voisin : voisins) {
                message += "\n- " + voisin.getId();
            }
            JOptionPane.showMessageDialog(null, message, "Information", JOptionPane.INFORMATION_MESSAGE);
        }
    }//GEN-LAST:event_listVoisinButtonActionPerformed

    /**
     * Affiche la liste des voisins d'un centre de santé sélectionné selon un
     * type spécifié.
     *
     * @param evt L'événement d'action déclenché par le bouton
     */
    private void listVoisinTypeButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_listVoisinTypeButtonActionPerformed
        // Vérifie si un graphe a été créé
        if (graphe == null) {
            JOptionPane.showMessageDialog(null, "Aucun graphe n'a été créé. Veuillez d'abord créer un graphe.", "Erreur", JOptionPane.ERROR_MESSAGE);
            return;
        }

        // Vérifie si la liste des routes est vide
        if (graphe.getRoutesMap().isEmpty()) {
            JOptionPane.showMessageDialog(null, "La liste des routes est vide.", "Erreur", JOptionPane.ERROR_MESSAGE);
            return;
        }

        // Crée une liste de tous les centres de santé
        List<CentreDeSante> centres = new ArrayList<>(graphe.getRoutesMap().keySet());

        // Trie la liste des centres de santé en utilisant la valeur numérique qui suit le "S" dans l'ID du centre
        centres.sort(Comparator.comparing(c -> Integer.parseInt(c.getId().substring(1))));

        // Crée une liste de tous les types de centres de santé possibles
        List<String> types = Arrays.asList("M", "O", "N");

        // Demande à l'utilisateur de choisir un centre de santé
        Object selectedCentre = JOptionPane.showInputDialog(null, "Choisissez un centre de santé :", "Sélection du centre de santé",
                JOptionPane.QUESTION_MESSAGE, null, centres.toArray(), centres.get(0));

        // Vérifie si l'utilisateur a sélectionné un centre de santé
        if (selectedCentre == null) {
            JOptionPane.showMessageDialog(null, "Vous devez choisir un centre de santé.", "Erreur", JOptionPane.ERROR_MESSAGE);
            return;
        }

        // Demande à l'utilisateur de choisir un type de centre de santé
        Object selectedType = JOptionPane.showInputDialog(null, "Choisissez un type de centre de santé :", "Sélection du type de centre de santé",
                JOptionPane.QUESTION_MESSAGE, null, types.toArray(), types.get(0));

        // Vérifie si l'utilisateur a sélectionné un type de centre de santé
        if (selectedType == null) {
            JOptionPane.showMessageDialog(null, "Vous devez choisir un type de centre de santé.", "Erreur", JOptionPane.ERROR_MESSAGE);
            return;
        }

        // Récupère les voisins du type spécifié
        List<CentreDeSante> voisins = graphe.getVoisinParType((CentreDeSante) selectedCentre, (String) selectedType);

        // Vérifie si le centre de santé a des voisins du type spécifié
        if (voisins.isEmpty()) {
            JOptionPane.showMessageDialog(null, "Le centre de santé sélectionné n'a pas de voisins du type spécifié.", "Information", JOptionPane.INFORMATION_MESSAGE);
        } else {
            String message = "Les voisins du type spécifié sont : ";
            for (CentreDeSante voisin : voisins) {
                message += "\n- " + voisin.getId();
            }
            JOptionPane.showMessageDialog(null, message, "Information", JOptionPane.INFORMATION_MESSAGE);
        }
    }//GEN-LAST:event_listVoisinTypeButtonActionPerformed

    /**
     * Affiche la liste des voisins de deux centres de santé sélectionnés selon
     * un type spécifié.
     *
     * @param evt L'événement d'action déclenché par le bouton
     */
    private void listVoisin2CentreTypeButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_listVoisin2CentreTypeButtonActionPerformed
        if (graphe == null) {
            JOptionPane.showMessageDialog(null, "Aucun graphe n'a été créé. Veuillez d'abord créer un graphe.", "Erreur", JOptionPane.ERROR_MESSAGE);
            return;
        }

        // Vérifie si la liste des routes est vide
        if (graphe.getRoutesMap().isEmpty()) {
            JOptionPane.showMessageDialog(null, "La liste des routes est vide.", "Erreur", JOptionPane.ERROR_MESSAGE);
            return;
        }

        // Obtenir tous les sommets
        ArrayList<CentreDeSante> allCentres = new ArrayList<>(graphe.getRoutesMap().keySet());

        // Trie la liste des centres de santé en utilisant la valeur numérique qui suit le "S" dans l'ID du centre
        allCentres.sort(Comparator.comparing(c -> Integer.parseInt(c.getId().substring(1))));

        // Demander à l'utilisateur de sélectionner le premier sommet
        CentreDeSante centre1 = null;
        try {
            centre1 = (CentreDeSante) JOptionPane.showInputDialog(null, "Choisissez le premier sommet :", "Sélection du sommet", JOptionPane.QUESTION_MESSAGE, null, allCentres.toArray(), allCentres.get(0));
            if (centre1 == null) {
                // L'utilisateur a annulé la sélection
                return;
            }
        } catch (Exception e) {
            JOptionPane.showMessageDialog(null, "Erreur lors de la sélection du premier sommet : " + e.getMessage(), "Erreur", JOptionPane.ERROR_MESSAGE);
            return;
        }

        // Demander à l'utilisateur de sélectionner le deuxième sommet
        CentreDeSante centre2 = null;
        try {
            centre2 = (CentreDeSante) JOptionPane.showInputDialog(null, "Choisissez le deuxième sommet :", "Sélection du sommet", JOptionPane.QUESTION_MESSAGE, null, allCentres.toArray(), allCentres.get(0));
            if (centre2 == null) {
                // L'utilisateur a annulé la sélection
                return;
            }
        } catch (Exception e) {
            JOptionPane.showMessageDialog(null, "Erreur lors de la sélection du deuxième sommet : " + e.getMessage(), "Erreur", JOptionPane.ERROR_MESSAGE);
            return;
        }

        // Demander à l'utilisateur de sélectionner le type
        String[] types = {"N", "O", "M"};
        String type = null;
        try {
            type = (String) JOptionPane.showInputDialog(null, "Choisissez le type :", "Sélection du type", JOptionPane.QUESTION_MESSAGE, null, types, types[0]);
            if (type == null) {
                // L'utilisateur a annulé la sélection
                return;
            }
        } catch (Exception e) {
            JOptionPane.showMessageDialog(null, "Erreur lors de la sélection du type : " + e.getMessage(), "Erreur", JOptionPane.ERROR_MESSAGE);
            return;
        }

        // Récupérer les voisins du type spécifié pour les deux sommets sélectionnés
        List<CentreDeSante> voisins1 = graphe.getVoisinParType(centre1, type);
        List<CentreDeSante> voisins2 = graphe.getVoisinParType(centre2, type);

        // Construire les messages à afficher
        StringBuilder output = new StringBuilder();
        output.append("Voisins du type ").append(type).append(" pour le premier sommet sélectionné (ID ").append(centre1.getId()).append("):\n");
        if (voisins1.isEmpty()) {
            output.append("Aucun voisin du type ").append(type).append(" trouvé pour le premier sommet.\n");
        } else {
            for (CentreDeSante voisin : voisins1) {
                output.append(voisin.getId()).append("\n");
            }
        }

        output.append("\nVoisins du type ").append(type).append(" pour le deuxième sommet sélectionné (ID ").append(centre2.getId()).append("):\n");
        if (voisins2.isEmpty()) {
            output.append("Aucun voisin du type ").append(type).append(" trouvé pour le deuxième sommet.\n");
        } else {
            for (CentreDeSante voisin : voisins2) {
                output.append(voisin.getId()).append("\n");
            }
        }

        JOptionPane.showMessageDialog(null, output.toString(), "Résultat", JOptionPane.INFORMATION_MESSAGE);
    }//GEN-LAST:event_listVoisin2CentreTypeButtonActionPerformed

    /**
     * Vérifie si les deux centres de santé sont à une distance de deux arcs
     * dans le graphe. Affiche un message d'information correspondant.
     *
     * @param evt L'événement déclencheur
     */
    private void voisin2DistancesOuNonButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_voisin2DistancesOuNonButtonActionPerformed
        // Vérifie si un graphe a été créé
        if (graphe == null) {
            JOptionPane.showMessageDialog(null, "Aucun graphe n'a été créé. Veuillez d'abord créer un graphe.", "Erreur", JOptionPane.ERROR_MESSAGE);
            return;
        }

        // Vérifie si la liste des routes est vide
        if (graphe.getRoutesMap().isEmpty()) {
            JOptionPane.showMessageDialog(null, "La liste des routes est vide.", "Erreur", JOptionPane.ERROR_MESSAGE);
            return;
        }

        // Obtenir tous les sommets
        ArrayList<CentreDeSante> allCentres = new ArrayList<>(graphe.getRoutesMap().keySet());

        // Trie la liste des centres de santé en utilisant la valeur numérique qui suit le "S" dans l'ID du centre
        allCentres.sort(Comparator.comparing(c -> Integer.parseInt(c.getId().substring(1))));

        // Demander à l'utilisateur de sélectionner le premier sommet
        CentreDeSante centre1 = (CentreDeSante) JOptionPane.showInputDialog(null, "Choisissez le premier centre de santé :", "Sélection du centre de santé", JOptionPane.QUESTION_MESSAGE, null, allCentres.toArray(), allCentres.get(0));
        if (centre1 == null) {
            // L'utilisateur a annulé la sélection
            return;
        }

        // Demander à l'utilisateur de sélectionner le deuxième sommet
        CentreDeSante centre2 = (CentreDeSante) JOptionPane.showInputDialog(null, "Choisissez le deuxième centre de santé :", "Sélection du centre de santé", JOptionPane.QUESTION_MESSAGE, null, allCentres.toArray(), allCentres.get(0));
        if (centre2 == null) {
            // L'utilisateur a annulé la sélection
            return;
        }

        // Vérifie si les centres de santé sont à une distance de deux arcs
        List<CentreDeSante> centresA2distances = graphe.getVoisinA2Distances(centre1);

        if (centresA2distances.contains(centre2)) {
            JOptionPane.showMessageDialog(null, "Les centres de santé sont à une distance de deux arcs.", "Information", JOptionPane.INFORMATION_MESSAGE);
        } else {
            JOptionPane.showMessageDialog(null, "Les centres de santé ne sont pas à une distance de deux arcs.", "Information", JOptionPane.INFORMATION_MESSAGE);
        }
    }//GEN-LAST:event_voisin2DistancesOuNonButtonActionPerformed

    /**
     * Compare deux centres de santé en termes de types de centres situés à une
     * distance de deux arcs. Affiche les résultats de la comparaison dans une
     * boîte de dialogue.
     *
     * @param evt L'événement déclencheur
     */
    private void compare2CentresButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_compare2CentresButtonActionPerformed
        // Récupère tous les centres de santé
        ArrayList<CentreDeSante> allCentres = graphe.getCentreDeSanteList();

        // Vérifie si la liste des routes est vide
        if (graphe.getRoutesMap().isEmpty()) {
            JOptionPane.showMessageDialog(null, "La liste des routes est vide.", "Erreur", JOptionPane.ERROR_MESSAGE);
            return;
        }

        // Demande à l'utilisateur de sélectionner le premier centre de santé
        CentreDeSante centre1 = (CentreDeSante) JOptionPane.showInputDialog(null, "Choisissez le premier centre de santé :", "Sélection du centre de santé", JOptionPane.QUESTION_MESSAGE, null, allCentres.toArray(), allCentres.get(0));
        if (centre1 == null) {
            // L'utilisateur a annulé la sélection
            return;
        }

        // Demande à l'utilisateur de sélectionner le deuxième centre de santé
        CentreDeSante centre2 = (CentreDeSante) JOptionPane.showInputDialog(null, "Choisissez le deuxième centre de santé :", "Sélection du centre de santé", JOptionPane.QUESTION_MESSAGE, null, allCentres.toArray(), allCentres.get(0));
        if (centre2 == null) {
            // L'utilisateur a annulé la sélection
            return;
        }

        // Utilise getVoisinA2Distances pour trouver tous les centres situés à une distance de deux arcs des centres sélectionnés
        ArrayList<CentreDeSante> centresWithin2DistanceOfCentre1 = (ArrayList<CentreDeSante>) graphe.getVoisinA2Distances(centre1);
        ArrayList<CentreDeSante> centresWithin2DistanceOfCentre2 = (ArrayList<CentreDeSante>) graphe.getVoisinA2Distances(centre2);

        // Utilise des méthodes auxiliaires pour compter le nombre de centres de chaque type à une distance de deux arcs
        int numTypeOCentresCentre1 = getTypeCount(centresWithin2DistanceOfCentre1, "O");
        int numTypeNCentresCentre1 = getTypeCount(centresWithin2DistanceOfCentre1, "N");
        int numTypeMCentresCentre1 = getTypeCount(centresWithin2DistanceOfCentre1, "M");

        int numTypeOCentresCentre2 = getTypeCount(centresWithin2DistanceOfCentre2, "O");
        int numTypeNCentresCentre2 = getTypeCount(centresWithin2DistanceOfCentre2, "N");
        int numTypeMCentresCentre2 = getTypeCount(centresWithin2DistanceOfCentre2, "M");

        // Compare les compteurs et prépare les résultats
        String results = "Comparaison entre " + centre1.getId() + " et " + centre2.getId() + " :\n\n";

        results += "Centres de type O à une distance de deux arcs :\n";
        results += centre1.getId() + " : " + numTypeOCentresCentre1 + "\n";
        results += centre2.getId() + " : " + numTypeOCentresCentre2 + "\n";

        results += "Centres de type N à une distance de deux arcs :\n";
        results += centre1.getId() + " : " + numTypeNCentresCentre1 + "\n";
        results += centre2.getId() + " : " + numTypeNCentresCentre2 + "\n";

        results += "Centres de type M à une distance de deux arcs :\n";
        results += centre1.getId() + " : " + numTypeMCentresCentre1 + "\n";
        results += centre2.getId() + " : " + numTypeMCentresCentre2 + "\n";

        results += "\nCentre avec le plus de centres de type O à une distance de deux arcs :\n";
        results += (numTypeOCentresCentre1 > numTypeOCentresCentre2 ? centre1.getId() : centre2.getId()) + "\n";

        results += "Centre avec le plus de centres de type N à une distance de deux arcs :\n";
        results += (numTypeNCentresCentre1 > numTypeNCentresCentre2 ? centre1.getId() : centre2.getId()) + "\n";

        results += "Centre avec le plus de centres de type M à une distance de deux arcs :\n";
        results += (numTypeMCentresCentre1 > numTypeMCentresCentre2 ? centre1.getId() : centre2.getId()) + "\n";

        // Affiche les résultats dans une boîte de dialogue
        JOptionPane.showMessageDialog(null, results);
    }

    /**
     * Méthode auxiliaire pour compter le nombre de centres d'un certain type
     * dans une liste de centres.
     *
     * @param centres La liste de centres
     * @param type Le type de centre à compter
     * @return Le nombre de centres du type spécifié
     */
    private int getTypeCount(ArrayList<CentreDeSante> centres, String type) {
        int count = 0;

        for (CentreDeSante centre : centres) {
            if (centre.getType().equals(type)) {
                count++;
            }
        }

        return count;
    }//GEN-LAST:event_compare2CentresButtonActionPerformed

    /**
     * Recherche et affiche le chemin le plus court entre deux centres de santé
     * en termes de distance.
     *
     * @param evt l'événement déclencheur
     */
    private void cheminPlusCourtDistanceButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_cheminPlusCourtDistanceButtonActionPerformed
        try {
            // Récupère tous les centres
            ArrayList<CentreDeSante> allCentres = graphe.getCentreDeSanteList();

            if (allCentres.isEmpty()) {
                JOptionPane.showMessageDialog(null, "Il n'y a aucun centre de santé disponible.");
                return;
            }

            // Demande à l'utilisateur de sélectionner le premier centre de santé
            CentreDeSante centre1 = (CentreDeSante) JOptionPane.showInputDialog(null, "Choisissez le premier centre de santé :", "Sélection du centre de santé", JOptionPane.QUESTION_MESSAGE, null, allCentres.toArray(), allCentres.get(0));
            if (centre1 == null) {
                // L'utilisateur a annulé la sélection
                return;
            }

            // Demande à l'utilisateur de sélectionner le deuxième centre de santé
            CentreDeSante centre2 = (CentreDeSante) JOptionPane.showInputDialog(null, "Choisissez le deuxième centre de santé :", "Sélection du centre de santé", JOptionPane.QUESTION_MESSAGE, null, allCentres.toArray(), allCentres.get(0));
            if (centre2 == null) {
                // L'utilisateur a annulé la sélection
                return;
            }

            // Utilise l'algorithme de Dijkstra pour trouver le plus court chemin et sa distance
            Pair<ArrayList<CentreDeSante>, Integer> result = graphe.shortestPath(centre1, centre2);

            if (result == null) {
                JOptionPane.showMessageDialog(null, "Il n'y a pas de chemin entre " + centre1.getId() + " et " + centre2.getId() + ".");
            } else {
                ArrayList<CentreDeSante> path = result.getKey();
                Integer totalDistance = result.getValue();

                JOptionPane.showMessageDialog(null, "Le chemin le plus court entre " + centre1.getId() + " et " + centre2.getId() + " est " + path.stream().map(CentreDeSante::getId).collect(Collectors.joining(" -> ")) + " avec une distance totale de " + totalDistance + ".");
            }
        } catch (Exception e) {
            JOptionPane.showMessageDialog(null, "Une erreur est survenue : " + e.getMessage());
        }
    }//GEN-LAST:event_cheminPlusCourtDistanceButtonActionPerformed

    /**
     * Recherche et affiche le chemin le plus court entre deux centres de santé
     * en termes de durée moyenne.
     *
     * @param evt l'événement déclencheur
     */
    private void cheminPlusCourtDureeButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_cheminPlusCourtDureeButtonActionPerformed
        try {
            // Récupère tous les centres
            ArrayList<CentreDeSante> allCentres = graphe.getCentreDeSanteList();

            if (allCentres.isEmpty()) {
                JOptionPane.showMessageDialog(null, "Il n'y a aucun centre de santé disponible.");
                return;
            }

            // Demande à l'utilisateur de sélectionner le premier centre de santé
            CentreDeSante centre1 = (CentreDeSante) JOptionPane.showInputDialog(null, "Choisissez le premier centre de santé :", "Sélection du centre de santé", JOptionPane.QUESTION_MESSAGE, null, allCentres.toArray(), allCentres.get(0));
            if (centre1 == null) {
                // L'utilisateur a annulé la sélection
                return;
            }

            // Demande à l'utilisateur de sélectionner le deuxième centre de santé
            CentreDeSante centre2 = (CentreDeSante) JOptionPane.showInputDialog(null, "Choisissez le deuxième centre de santé :", "Sélection du centre de santé", JOptionPane.QUESTION_MESSAGE, null, allCentres.toArray(), allCentres.get(0));
            if (centre2 == null) {
                // L'utilisateur a annulé la sélection
                return;
            }

            // Utilise l'algorithme de Dijkstra pour trouver le plus court chemin et sa durée moyenne
            Pair<ArrayList<CentreDeSante>, Integer> result = graphe.shortestPathDureeMoyenne(centre1, centre2);

            if (result == null) {
                JOptionPane.showMessageDialog(null, "Il n'y a pas de chemin entre " + centre1.getId() + " et " + centre2.getId() + ".");
            } else {
                ArrayList<CentreDeSante> path = result.getKey();
                Integer totalDistance = result.getValue();

                JOptionPane.showMessageDialog(null, "Le chemin le plus court entre " + centre1.getId() + " et " + centre2.getId() + " est " + path.stream().map(CentreDeSante::getId).collect(Collectors.joining(" -> ")) + " avec une durée totale moyenne de " + totalDistance + ".");
            }
        } catch (Exception e) {
            JOptionPane.showMessageDialog(null, "Une erreur est survenue : " + e.getMessage());
        }
    }//GEN-LAST:event_cheminPlusCourtDureeButtonActionPerformed

    /**
     * Recherche et affiche le chemin le plus fiable entre deux centres de
     * santé.
     *
     * @param evt l'événement déclencheur
     */
    private void cheminPlusFiableButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_cheminPlusFiableButton1ActionPerformed
        try {
            // Récupère tous les centres
            ArrayList<CentreDeSante> allCentres = graphe.getCentreDeSanteList();

            if (allCentres.isEmpty()) {
                JOptionPane.showMessageDialog(null, "Il n'y a aucun centre de santé disponible.");
                return;
            }

            // Demande à l'utilisateur de sélectionner le premier centre de santé
            CentreDeSante centre1 = (CentreDeSante) JOptionPane.showInputDialog(null, "Choisissez le premier centre de santé :", "Sélection du centre de santé", JOptionPane.QUESTION_MESSAGE, null, allCentres.toArray(), allCentres.get(0));
            if (centre1 == null) {
                // L'utilisateur a annulé la sélection
                return;
            }

            // Demande à l'utilisateur de sélectionner le deuxième centre de santé
            CentreDeSante centre2 = (CentreDeSante) JOptionPane.showInputDialog(null, "Choisissez le deuxième centre de santé :", "Sélection du centre de santé", JOptionPane.QUESTION_MESSAGE, null, allCentres.toArray(), allCentres.get(0));
            if (centre2 == null) {
                // L'utilisateur a annulé la sélection
                return;
            }

            // Utilise l'algorithme de Dijkstra pour trouver le chemin le plus fiable
            Pair<ArrayList<CentreDeSante>, Double> result = graphe.mostReliablePath(centre1, centre2);

            if (result == null) {
                JOptionPane.showMessageDialog(null, "Il n'y a pas de chemin entre " + centre1.getId() + " et " + centre2.getId() + ".");
            } else {
                ArrayList<CentreDeSante> path = result.getKey();
                Double totalReliability = result.getValue();

                JOptionPane.showMessageDialog(null, "Le chemin le plus fiable entre " + centre1.getId() + " et " + centre2.getId() + " est " + path.stream().map(CentreDeSante::getId).collect(Collectors.joining(" -> ")) + " avec une fiabilité totale de " + totalReliability * 100 + "%.");
            }
        } catch (Exception e) {
            JOptionPane.showMessageDialog(null, "Une erreur est survenue : " + e.getMessage());
        }
    }//GEN-LAST:event_cheminPlusFiableButton1ActionPerformed

    private void informationMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_informationMenuItemActionPerformed
        // Crée un nouveau JFrame
        JFrame infoFrame = new JFrame("Information sur MediPath");

        // Configure le Layout du JFrame
        infoFrame.setLayout(new BoxLayout(infoFrame.getContentPane(), BoxLayout.Y_AXIS));

        // Crée un nouveau JPanel pour l'image
        JPanel imagePanel = new JPanel();
        imagePanel.setLayout(new BoxLayout(imagePanel, BoxLayout.X_AXIS));
        imagePanel.add(Box.createHorizontalGlue());

        // Charge l'image et l'ajoute au JPanel
        ImageIcon icon = new ImageIcon(getClass().getResource("/iconmedipath.png"));
        JLabel imageLabel = new JLabel(icon);
        imagePanel.add(imageLabel);
        imagePanel.add(Box.createHorizontalGlue());

        // Ajoute le JPanel d'image au JFrame
        infoFrame.add(imagePanel);

        // Crée un nouveau JPanel pour le texte
        JPanel textPanel = new JPanel();
        textPanel.setLayout(new BoxLayout(textPanel, BoxLayout.X_AXIS));
        textPanel.add(Box.createHorizontalGlue());

        // Crée le texte et l'ajoute au JPanel
        JLabel textLabel = new JLabel(
                "<html><div style='padding: 40px;'>"
                + "MediPath est une application innovante de planification d'itinéraires pour les dispensaires de santé dans une région donnée. Utilisant la théorie des graphes, cette application fournit des outils pour visualiser, analyser et optimiser les connexions entre les différents dispensaires sur une carte."
                + "<br><br>"
                + "<b>Utilité de l'Application :</b>"
                + "<br><br>"
                + "L'application Medipath a été conçue pour aider les responsables de la santé à maximiser l'efficacité des itinéraires de transport entre les dispensaires. En utilisant RouteMed, les utilisateurs peuvent :"
                + "<br><br>"
                + "<ul>"
                + "<li>Visualiser le Réseau</li>"
                + "<li>Analyser les Voisinages</li>"
                + "<li>Comparer les Dispensaires</li>"
                + "<li>Modifier les Caractéristiques du Graphe</li>"
                + "<li>Trouver le Chemin le Plus Fiable</li>"
                + "<li>Trouver le Chemin le Plus Court</li>"
                + "</ul>"
                + "<br>"
                + "L'application Medipath est un outil essentiel pour quiconque cherche à améliorer l'efficacité et la fiabilité du transport dans un réseau de dispensaires."
                + "</div></html>");
        textLabel.setHorizontalAlignment(JLabel.CENTER);
        textPanel.add(textLabel);
        textPanel.add(Box.createHorizontalGlue());

        // Ajoute le JPanel de texte au JFrame
        infoFrame.add(textPanel);

        // Configure le JFrame pour qu'il apparaisse au centre de l'écran et le rend visible
        infoFrame.pack();
        infoFrame.setLocationRelativeTo(null);
        infoFrame.setVisible(true);
        infoFrame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
    }//GEN-LAST:event_informationMenuItemActionPerformed
    /**
     * Gère l'action à effectuer lorsque l'utilisateur clique sur le bouton
     * "Routes Dangereuses". Cette méthode récupère la liste des routes à partir
     * du graphe, vérifie si le graphe existe et si la liste des routes n'est
     * pas vide. Ensuite, elle demande à l'utilisateur de choisir une plage de
     * fiabilité en utilisant deux JSliders dans une boîte de dialogue. Ensuite,
     * elle filtre la liste des routes pour inclure uniquement celles dont la
     * fiabilité se situe dans la plage sélectionnée par l'utilisateur. Ces
     * routes sont ajoutées à un modèle de tableau qui est ensuite affiché dans
     * une nouvelle fenêtre JFrame.
     *
     * @param evt L'événement de clic de bouton qui a déclenché cette méthode.
     */
    private void routesParFiabiliteButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_routesParFiabiliteButtonActionPerformed
        // Vérifie si un graphe a été créé
        if (graphe == null) {
            JOptionPane.showMessageDialog(null, "Aucun graphe n'a été créé. Veuillez d'abord créer un graphe.", "Erreur", JOptionPane.ERROR_MESSAGE);
            return;
        }

        // Récupère la liste des routes
        HashMap<CentreDeSante, ArrayList<Route>> routesMap = graphe.getRoutesMap();

        // Vérifie si la liste des routes est vide
        if (routesMap.isEmpty()) {
            System.out.println("La liste des routes est vide.");
            JOptionPane.showMessageDialog(null, "La liste des routes est vide.", "Erreur", JOptionPane.ERROR_MESSAGE);
            return;
        }

        // Demander à l'utilisateur de choisir la plage de fiabilité avec un JSlider
        JPanel panel = new JPanel();
        panel.setLayout(new BoxLayout(panel, BoxLayout.Y_AXIS));
        panel.add(new JLabel("Choisir la plage de fiabilité(min/max):"));

        JSlider minSlider = new JSlider(0, 100, 0);
        minSlider.setMajorTickSpacing(10);
        minSlider.setMinorTickSpacing(5);
        minSlider.setPaintTicks(true);
        minSlider.setPaintLabels(true);
        panel.add(minSlider);

        JSlider maxSlider = new JSlider(0, 100, 100);
        maxSlider.setMajorTickSpacing(10);
        maxSlider.setMinorTickSpacing(5);
        maxSlider.setPaintTicks(true);
        maxSlider.setPaintLabels(true);
        panel.add(maxSlider);

        JOptionPane.showMessageDialog(null, panel);

        double minFiabilite = minSlider.getValue();
        double maxFiabilite = maxSlider.getValue();

        // Crée un modèle de tableau pour contenir les informations des routes
        DefaultTableModel model = new DefaultTableModel() {
            @Override
            public boolean isCellEditable(int row, int column) {
                // Toutes les cellules sont non modifiables
                return false;
            }
        };
        model.addColumn("Départ");
        model.addColumn("Destination");
        model.addColumn("Distance");
        model.addColumn("Durée Moyenne");
        model.addColumn("Fiabilité");

        // Ajoute les informations de chaque route au modèle de tableau
        for (Map.Entry<CentreDeSante, ArrayList<Route>> entry : routesMap.entrySet()) {
            ArrayList<Route> routes = entry.getValue();

            for (Route route : routes) {
                double fiabilite = route.getFiabilite();

                // Vérifie si la fiabilité est entre minFiabilite et maxFiabilite
                if (fiabilite >= minFiabilite && fiabilite <= maxFiabilite) {
                    CentreDeSante depart = entry.getKey();
                    CentreDeSante destination = route.getDestination();
                    int distance = route.getDistance();
                    int dureeMoyenne = route.getDureeMoyenne();

                    // Ajoute les informations de la route au modèle de tableau
                    model.addRow(new Object[]{
                        depart != null ? depart.getId() : "null",
                        destination != null ? destination.getId() : "null",
                        distance,
                        dureeMoyenne,
                        fiabilite
                    });
                }
            }
        }

        // Crée une nouvelle JFrame
        JFrame frame = new JFrame("Routes Dangereuses");
        frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);  // ferme la fenêtre lorsque l'utilisateur clique sur le bouton de fermeture

        // Crée un nouveau JTable à partir du modèle et l'ajoute à la JFrame
        JTable table = new JTable(model);
        JScrollPane scrollPane = new JScrollPane(table);
        frame.add(scrollPane, BorderLayout.CENTER);

        // Affiche la JFrame
        frame.pack();
        frame.setVisible(true);
    }//GEN-LAST:event_routesParFiabiliteButtonActionPerformed

    /**
     * Gère l'action à effectuer lorsque l'utilisateur clique sur le bouton
     * "Centre par Type". Cette méthode récupère la liste des centres de santé à
     * partir du graphe, vérifie si le graphe existe et si la liste des centres
     * n'est pas vide. Ensuite, elle demande à l'utilisateur de choisir un type
     * de centre de santé (Maternité, Bloc opératoire ou Centre de Nutrition)
     * via une JOptionPane. Ensuite, elle filtre la liste des centres de santé
     * pour n'inclure que ceux qui correspondent au type choisi par
     * l'utilisateur. Ces centres de santé sont ajoutés à un modèle de tableau
     * qui est ensuite affiché dans une nouvelle fenêtre JFrame.
     *
     * @param evt L'événement de clic de bouton qui a déclenché cette méthode.
     */
    private void centreParTypeButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_centreParTypeButtonActionPerformed
        // Vérifie si un graphe a été créé
        if (graphe == null) {
            JOptionPane.showMessageDialog(null, "Aucun graphe n'a été créé. Veuillez d'abord créer un graphe.", "Erreur", JOptionPane.ERROR_MESSAGE);
            return;
        }

        // Récupère la liste des centres de santé
        ArrayList<CentreDeSante> centreList = graphe.getCentreDeSanteList();

        if (centreList.isEmpty()) {
            JOptionPane.showMessageDialog(null, "Il n'y a pas de centres de santé.", "Erreur", JOptionPane.ERROR_MESSAGE);
            return;
        }

        // Demande à l'utilisateur de choisir un type de centre de santé
        Object[] options = {"Maternité", "Bloc opératoire", "Centre de Nutrition"};
        String input = (String) JOptionPane.showInputDialog(null, "Choisissez un type de centre de santé:",
                "Selection du Type", JOptionPane.QUESTION_MESSAGE, null, options, options[0]);

        // Définit le type en fonction de la sélection de l'utilisateur
        String type;
        switch (input) {
            case "Maternité":
                type = "M";
                break;
            case "Bloc opératoire":
                type = "O";
                break;
            case "Centre de Nutrition":
                type = "N";
                break;
            default:
                return;
        }

        // Filtrer la liste des centres de santé par type
        centreList = centreList.stream()
                .filter(centre -> type.equals(centre.getType()))
                .collect(Collectors.toCollection(ArrayList::new));

        // Crée un modèle de tableau pour contenir les informations des centres de santé
        DefaultTableModel model = new DefaultTableModel() {
            @Override
            public boolean isCellEditable(int row, int column) {
                // Toutes les cellules sont non modifiables
                return false;
            }
        };
        model.addColumn("ID");
        model.addColumn("Type");

        // Ajoute les informations de chaque centre de santé au modèle de tableau
        for (CentreDeSante centre : centreList) {
            String id = centre.getId();
            String typeCentre = centre.getType();

            // Ajoute les informations du centre de santé au modèle de tableau
            model.addRow(new Object[]{
                id,
                typeCentre
            });
        }

        // Crée une nouvelle JFrame
        JFrame frame = new JFrame("Liste des Centres de Santé par Type");
        frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);  // ferme la fenêtre lorsque l'utilisateur clique sur le bouton de fermeture

        // Crée un nouveau JTable à partir du modèle et l'ajoute à la JFrame
        JTable table = new JTable(model);
        JScrollPane scrollPane = new JScrollPane(table);
        frame.add(scrollPane, BorderLayout.CENTER);

        // Affiche la JFrame
        frame.pack();
        frame.setVisible(true);
    }//GEN-LAST:event_centreParTypeButtonActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        FlatIntelliJLaf.setup();

        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            @Override
            public void run() {
                MainApplication mainApp = new MainApplication();
                mainApp.createGrapheInstance(); // Create the Graphe instance
                mainApp.setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton addCentreButton;
    private javax.swing.JButton addRouteButton;
    private javax.swing.JButton adjacenceListButton;
    private javax.swing.JLabel adjacenceListStatusLabel;
    private javax.swing.JButton centreListButton;
    private javax.swing.JButton centreParTypeButton;
    private javax.swing.JPanel chargementMenuPanel;
    private javax.swing.JPanel cheminMenuPanel;
    private javax.swing.JButton cheminPlusCourtDistanceButton;
    private javax.swing.JButton cheminPlusCourtDureeButton;
    private javax.swing.JButton cheminPlusFiableButton1;
    private javax.swing.JButton compare2CentresButton;
    private javax.swing.JButton deleteCentreButton;
    private javax.swing.JButton deleteRouteButton;
    private javax.swing.JButton editAdjacenceFileButton;
    private javax.swing.JButton editCentreButton;
    private javax.swing.JPanel editFilePanel;
    private javax.swing.JPanel editPanel;
    private javax.swing.JButton editRouteButton;
    private javax.swing.JButton editVoisinFileButton;
    private javax.swing.JPanel graphPanel;
    private javax.swing.JButton grapheCreationButton;
    private javax.swing.JPanel grapheMenuPanel;
    private javax.swing.JButton infoGrapheButton;
    private javax.swing.JMenuItem informationMenuItem;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JMenu jMenu1;
    private javax.swing.JMenuBar jMenuBar1;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JPanel jPanel3;
    private javax.swing.JSeparator jSeparator1;
    private javax.swing.JSeparator jSeparator2;
    private javax.swing.JSeparator jSeparator3;
    private javax.swing.JPopupMenu.Separator jSeparator4;
    private javax.swing.JPanel legendePanel;
    private javax.swing.JPanel listPanel;
    private javax.swing.JButton listVoisin2CentreTypeButton;
    private javax.swing.JButton listVoisinButton;
    private javax.swing.JButton listVoisinTypeButton;
    private javax.swing.JLabel logoLabel;
    private javax.swing.JTabbedPane menuTabbedPane;
    private javax.swing.JPanel principalMenuPanel;
    private javax.swing.JMenuItem quitMenuItem;
    private javax.swing.JButton routeListButton;
    private javax.swing.JButton routesParFiabiliteButton;
    private javax.swing.JPanel typePanel;
    private javax.swing.JButton voisin2DistancesOuNonButton;
    private javax.swing.JButton voisinListButton;
    private javax.swing.JLabel voisinListStatusLabel;
    private javax.swing.JPanel voisinagePanel;
    // End of variables declaration//GEN-END:variables

}
